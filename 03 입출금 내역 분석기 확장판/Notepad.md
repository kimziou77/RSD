### 함수형 인터페이스
한 개의 추상 메서드를 포함하는 인터페이스를 함수형 인터페이스라고 부른다.
자바 8에서 처음 이 용어를 소개했다.
`@FuntionalInterface`어노테이션을 사용하면 의도를 더 명확하게 표현할 수 있다.

### 명시적 API vs 암묵적 API
코드 베이스에 불필요한 추상화를 추가해 일을 복잡하게 만들 필요가 없다.
일반적인 메서드를 쉽게 정의할 수 있는 상황에서 구체적으로 메서드를 정의해야 하는지 의문도 생긴다.
이런 딜레마를 `명시적 API 제공 vs 암묵적 API 제공` 문제 라고 부른다.

### 자바의 예외 계층도
자바의 예외 계층도는 다음과 같다.

[![image](https://user-images.githubusercontent.com/41179265/152790887-836ef55c-1a4c-4064-b05f-48ee56fbbf25.png)](https://blog.jiktong.kr/2226)
`Error`와 `RuntimeException`은 **미확인 예외**이며 보통 이런 오류는 잡지 않는다.
`Exception`클래스는 **확인된 예외**로, 일반적으로 프로그램에서 잡아 회복해야 하는 오류를 가리킨다.
- **확인된 예외**
    - 회복해야 하는 대상
    - 메서드가 던질 수 있는 확인된 예외 목록을 선언해야 한다.
    - 아니면 해당 예외를 try/catch로 처리한다.
- **미확인 예외**
    -  프로그램을 실행하면서 언제든 발생할 수 있는 종류의 예외다.
    - 명시적으로 오류를 선언하지 않으면 이를 꼭 처리할 필요가 없다.


### 과도하게 세밀함 & 과도하게 덤덤함
- **과도하게 세밀함**  
입력에서 발생할 수 있는 모든 경계상황을 고려하고
각각의 경계상황을 별도의 확인된 예외로 변환했다.
이 방법을 적용하면 각각의 예외에 적합하고 정확한 회복 기법을 구현할 수 있지만
너무 많은 설정 작업이 필요하고, 여러 예외를 선언해야 하며, 사용자가 이 모든 예외를 처리해야 하므로 생산성이 현저하게 떨어진다.
즉 사용자가 API를 쉽게 사용할 수 없게 된다.
게다가 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다.


- **과도하게 덤덤함**  
위와 반대로 모든 예외를 `illegalArgumentException`등의 미확인 예외로 지정하는 극단적인 상황도 있다.
전부 동일한 예외로 지정하면 구체적인 회복 로직을 만들 수 없는 문제가 생긴다.
  마찬가지로 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다.

위 과도하게 세밀함/덤덤함 에서 발생한 문제를 해결하기위해 노티피케이션 패턴을 배워보자. 
### 노티피케이션 패턴
노티피케이션 패턴은 너무 많은 미확인 예외를 사용하는 상황에 적합한 해결책을 제공한다.

### 예외 사용 가이드라인
- **예외를 무시하지 않음**  
  - 문제의 근본원인을 알 수 없다고 무시하지 말자.
  - 예외를 처리할 수 있는 방법이 명확하지 않으면 미확인 예외를 대신 던진다.
  - 이렇게 되면 런타임에 문제를 확인한 후 필요한 작업을 다시 시작할 수 있다.
- **일반적인 예외는 잡지 않음**
  - 가능한 구체적으로예외를 잡으면 가독성이 높아지고 더 세밀하게 예외를 처리할 수 있다.
  - 자동 생성된 코드를 더 구체적으로 개선할 수 있는지 고민해보자.
- **예외 문서화**
    - API 사용자에게 문제 해결의 실마리를 제공한다.
    - @throws 자바독 문법으로 예외를 문서화..
- **특정 구현에 종속된 예외를 주의할 것**
- **예외 vs 제어흐름**
    - 예외로 흐름을 제어하지 않는다.
    - 예외를 정말 던져야 하는 상황이 아니라면 예외를 만들지 않아야 한다.
      (try/catch문법이 추가되어 코드 가독성을 떨어뜨리고 의도도 이해하기 힘들다.)
      
