### 함수형 인터페이스
한 개의 추상 메서드를 포함하는 인터페이스를 함수형 인터페이스라고 부른다.
자바 8에서 처음 이 용어를 소개했다.
`@FuntionalInterface`어노테이션을 사용하면 의도를 더 명확하게 표현할 수 있다.

### 명시적 API vs 암묵적 API
코드 베이스에 불필요한 추상화를 추가해 일을 복잡하게 만들 필요가 없다.
일반적인 메서드를 쉽게 정의할 수 있는 상황에서 구체적으로 메서드를 정의해야 하는지 의문도 생긴다.
이런 딜레마를 `명시적 API 제공 vs 암묵적 API 제공` 문제 라고 부른다.

### 자바의 예외 계층도
자바의 예외 계층도는 다음과 같다.

[![image](https://user-images.githubusercontent.com/41179265/152790887-836ef55c-1a4c-4064-b05f-48ee56fbbf25.png)](https://blog.jiktong.kr/2226)
`Error`와 `RuntimeException`은 **미확인 예외**이며 보통 이런 오류는 잡지 않는다.
`Exception`클래스는 **확인된 예외**로, 일반적으로 프로그램에서 잡아 회복해야 하는 오류를 가리킨다.
- **확인된 예외**
    - 회복해야 하는 대상
    - 메서드가 던질 수 있는 확인된 예외 목록을 선언해야 한다.
    - 아니면 해당 예외를 try/catch로 처리한다.
- **미확인 예외**
    -  프로그램을 실행하면서 언제든 발생할 수 있는 종류의 예외다.
    - 명시적으로 오류를 선언하지 않으면 이를 꼭 처리할 필요가 없다.


### 과도하게 세밀함 & 과도하게 덤덤함
- **과도하게 세밀함**  
입력에서 발생할 수 있는 모든 경계상황을 고려하고
각각의 경계상황을 별도의 확인된 예외로 변환했다.
이 방법을 적용하면 각각의 예외에 적합하고 정확한 회복 기법을 구현할 수 있지만
너무 많은 설정 작업이 필요하고, 여러 예외를 선언해야 하며, 사용자가 이 모든 예외를 처리해야 하므로 생산성이 현저하게 떨어진다.
즉 사용자가 API를 쉽게 사용할 수 없게 된다.
게다가 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다.


- **과도하게 덤덤함**  
위와 반대로 모든 예외를 `illegalArgumentException`등의 미확인 예외로 지정하는 극단적인 상황도 있다.
전부 동일한 예외로 지정하면 구체적인 회복 로직을 만들 수 없는 문제가 생긴다.
  마찬가지로 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다.

위 과도하게 세밀함/덤덤함 에서 발생한 문제를 해결하기위해 노티피케이션 패턴을 배워보자. 
### 노티피케이션 패턴
노티피케이션 패턴은 너무 많은 미확인 예외를 사용하는 상황에 적합한 해결책을 제공한다.
