### 도메인
도메인은 비즈니스 문제와 동일한 단어와 용어를 사용한다는 의미이다.

### DRY 원칙
Don't Repeat Yourself

### final 변수
이 변수에 값을 재할당할 수 없다.  
자바10에서 var 키워드가 등장하며 final 유용성이 크게 감소되었다.
final 필드로 가리키는 객체라도 가변상태를 포함한다.  
추상 메서드의 메서드 파라미터에 final을 사용하는 경우
실제 구현이 없으므로 final 키워드의 의미가 무력화 되어 fianl 키워드가 쓸모없는 상황이 된다.

### 코드 유지보수성과 안티패턴
코드를 구현할 때는 코드 유지보수성을 높이기 위해 노력한다.
이게 무슨 의미일까? 구현하는 코드가 가졌으면 하는 속성을 목록으로 만들어보자.
- 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야 한다.
- 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야 한다.
- 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야 한다.
- 캡슐화가 잘 되어 있어야 한다.
  즉 코드 사용자에게는 세부 구현 내용이 감춰져 있으므로 사용자가 쉽게 코드를 이해하고,
  기능을 바꿀 수 있어야 한다. 
  
### 갓 클래스
한 개의 파일에 모든 코드를 구현하면
클래스의 목적이 무엇인지 이해하기 어렵고
클래스의 목적이 무엇인지 이해하기 어려워 진다.
이런 문제를 **갓 클래스 안티패턴** 이라고 부른다.
이런 패턴이 나오지 않도록 도움을 주는 **단일책임원칙을(SRP)** 배운다.
- 클래스가 바뀌어야 하는 이유는 오직 하나여야 한다.
- 한 클래스는 한 기능만 책임진다.

### 코드 중복
우리의 예제에서 데이터 형식이 바뀐다면 비슷한 문제가 발생한다.
결론적으로 코드를 간결하게 유지하는 것도 중요하지만 
**KISS 원칙을 남용하지 않아야 한다.** (keep it short and simple)
한 문제를 작은 개별 문제로 분리해 더 쉽게 관리 할 수 있는지 파악해야 한다.
이 과정을 통해 더 이해하기 쉽고, 쉽게 유지보수하며,
새로운 요구사항도 쉽게 적용하는 결과물을 만들 수 있다.

## 응집도(Cohesion)
응집도는 코드 유지보수성을 결정하는 중요한 개념이다.
응집도는 서로 어떻게 관련되어 있는지를 가리킨다.
정확히 말하자면 클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 측정한다.
보통 응집도 개념은 클래스에 적용하지만, 이를 메서드에도 적용할 수 있다.

### 클래스 수준 응집도
실무에서는 일반적으로 다음과 같은 여섯 가지 방법으로 그룹화 한다.
- [기능](#기능)
- [정보](#데이터-접근-객체(DAO))
- [유틸리티](#유틸리티)
- [논리](#논리)
- [순차](#순차)
- [시간](#시간)

#### 기능
기능이 비슷한 메서드를 그룹화 한다.  
함께 사용하는 메서드를 그룹화 하면 찾기도 쉽고 이해하기도 쉬우므로 응집도를 높인다.
다만, 한개의 메서드만을 갖는 클래스를 너무 과도하게 만들려는 경향이 발생할 수 있다.
간단한 클래스를 과도하게 만들면 그만큼 생각해야 할 클래스가 많아지므로 코드가 장황해지고 복잡해진다.

`장점` : 이해하기 쉬움  
`단점` : 너무 단순한 클래스 생성  
`응집도` : 높음

#### 데이터 접근 객체(DAO)
테이블이나 특정 도메인 객체를 저장하는 데이터베이스와 상호작용할 때 흔히 볼 수 있다.
이 패턴을 보통 DAO라 부르며 객체를 식별하는 일종의 id가 필요하다.
기본적으로 DAO는 영구 저장 데이터베이스나 인메모리 데이터베이스 같은
**데이터 소스로의 접근을 추상화하고 캡슐화** 한다.  
`장점` : 유지보수하기 쉬움  
`단점` : 불필요한 디펜덴시  
`응집도` : 중간

#### 유틸리티
관련성이 없는 메서드를 한 클래스로 포함시킨다.
메서드가 서로 연관성이 없으므로 클래스 전체의 기능을 추론하기 어렵다.
**유틸리티 클래스 사용은 낮은 응집도로 이어지므로 자제해야 한다.**  
`장점` : 간단히 추가 기능  
`단점` : 클래스의 책임을 파악하기 어려움  
`응집도` : 낮음

#### 논리
CSV, JSON, XML 자료를 파싱하는 코드를 한 클래스에 그룹화 한다면,    
각 메서드는 '파싱'이라는 논리로 그룹화 되어 있지만 서로 관련이 없다.  
또한 이렇게 그룹화 하면, 클래스는 네가지 책임을 갖게 되므로 이전에 배웠던 SRP를 위배한다.  
결과적으로 이 방법을 권장하지 않는다.  
`장점` : 높은 수준의 카테고리화 제공  
`단점` : SRP를 위배할 수 있음.  
`응집도` : 중간

#### 순차
입출력이 순차적으로 흐르는 것을 순차 응집이라고 한다.  
ex) 파일을 읽고- 파싱하고 - 처리하고 - 정보를 저장하는 과정을 그룹화  
실전에서 순차응집을 적용하면, 한 클래스를 바꿔야 할 여러 이유가 존재하므로 SRP를 위배한다.
더욱 처리.요약.저장하는 방식이 다양하므로 이 기법은 클래스를 순식간에 복잡하게 만든다.
따라서 **각 책임을 개별적으로 응집된 클래스로 분리하는 것이 더 좋은 방법**이다.  
`장점` : 관련 동작을 찾기 쉬움  
`단점` : SRP를 위배할 수 있음  
`응집도` : 중간

#### 시간
어떤 처리 작업을 시작하기 전과 뒤에 초기화, 뒷정리 작업을 담당하는 메서드를 포함하는 클래스가 예시이다.  
`장점` : 판단불가  
`단점` : 각 동작을 이해하고 사용하기 어려움  
`응집도` : 낮음